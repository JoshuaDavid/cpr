#include <stdio.h>
#include <stdlib.h>

#define NODE struct node
#define CONN struct connection
#define NETW struct network
#define DMAT struct distance_matrix

NODE {
    char *name;
    float x;
    float y;
    float fx;
    float fy;
};

CONN {
    NODE *node1;
    NODE *node2;
    float distance;
};

NETW {
    NODE **nodes;
    CONN **connections;
};

DMAT {
    char **names;
    int num_sets;
    float **distances;
};

// Calculate the Hooke force on the two nodes that is generated by the 
// difference between the actual distance between them and the distance
// between their xy positions. Add that force to fx and fy.
void addHookeForce(CONN *conn) {
    // The total Hooke force scales linearly with the difference between the
    // distance from the distance matrix and the xy difference.

    NODE *a = conn->node1;
    NODE *b = conn->node2;

    float dx = b->x - a->x;
    float dy = b->y - a->y;

    // Pythagoras
    float dist = dx * dx + dy * dy;
    
    // Positive means the nodes want to get farther apart
    float diff = conn->distance - dist;

    float fx = 0.0;
    float fy = 0.0;

    if(dist == 0) {
        // Randomize the vector that gives the xy distance
        dx = (float)(rand() - rand()) / RAND_MAX;
        dy = (float)(rand() - rand()) / RAND_MAX;
        dist = dx * dx + dy * dy;
        // This will still apply the correct amount of force in a random
        // direction.
        fx = dx * dx * diff / dist;
        fy = dy * dy * diff / dist;
    } else {
        // If dx is 0, there is no force along the x axis.
        fx = dx * dx * diff / dist;
        // If dy is 0, there is no force along the y axis.
        fy = dy * dy * diff / dist;
    }

    a->fx -= fx;
    a->fy -= fy;
    b->fx += fx;
    b->fy += fy;

    return;
}

NETW *netwFromDmat(DMAT *dmat) {
    int i = 0;
    int j = 0;
    int nsets = dmat->num_sets;
    NODE *nodeps = calloc(nsets, sizeof(NODE *));
    NODE *nodes = calloc(nsets, sizeof(NODE));
    // Because we don't care about the connection between a node and itself.
    CONN *connps = calloc(nsets * (nsets - 1), sizeof(CONN *));
    CONN *conns = calloc(nsets * (nsets - 1), sizeof(CONN));

    // Initialize the nodes
    for(i = 0; i < nsets; i++) {
        nodes[i].name = DMAT->names[i];
        nodes[i].x = (float)(rand() / RAND_MAX);
        nodes[i].y = (float)(rand() / RAND_MAX);
        nodes[i].fx = 0;
        nodes[i].fy = 0;
        nodeps[i] = &(nodes[i]);
    }

    int k = 0;
    for(i = 0; i < nsets; i++) {
        for(j = 0; j < nsets; j++) {
            if(i != j) {
                connps[k] = &(conns[k]);
                conns[k].node1 = nodeps[i];
                conns[k].node2 = nodeps[j];
                conns[k].distance = dmat->distances[i][j];
                k++;
            }
        }
    }

    NETW *net = calloc(1, sizeof NETW);
    net->nodes = nodeps;
    net->connections = connps;
    return net;
}

