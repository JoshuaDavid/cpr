#include <stdio.h>
#include <stdlib.h>

#define NODE struct node
#define CONN struct connection
#define NETW struct network
#define DMAT struct distance_matrix

NODE {
    char *name;
    float x;
    float y;
    float fx;
    float fy;
};

CONN {
    NODE *node1;
    NODE *node2;
    float distance;
};

NETW {
    NODE **nodes;
    CONN **connections;
};

DMAT {
    char **names;
    float **distances;
};

// Calculate the Hooke force on the two nodes that is generated by the 
// difference between the actual distance between them and the distance
// between their xy positions. Add that force to fx and fy.
void addHookeForce(CONN *conn) {
    // The total Hooke force scales linearly with the difference between the
    // distance from the distance matrix and the xy difference.

    NODE *a = conn->node1;
    NODE *b = conn->node2;

    float dx = b->x - a->x;
    float dy = b->y - a->y;

    // Pythagoras
    float dist = dx * dx + dy * dy;
    
    // Positive means the nodes want to get farther apart
    float diff = conn->distance - dist;

    float fx = 0.0;
    float fy = 0.0;

    if(dist == 0) {
        // Randomize the vector that gives the xy distance
        dx = (float)(rand() - rand()) / RAND_MAX;
        dy = (float)(rand() - rand()) / RAND_MAX;
        dist = dx * dx + dy * dy;
        // This will still apply the correct amount of force in a random
        // direction.
        fx = dx * dx * diff / dist;
        fy = dy * dy * diff / dist;
    } else {
        // If dx is 0, there is no force along the x axis.
        fx = dx * dx * diff / dist;
        // If dy is 0, there is no force along the y axis.
        fy = dy * dy * diff / dist;
    }

    a->fx -= fx;
    a->fy -= fy;
    b->fx += fx;
    b->fy += fy;

    return;
}

NETW *netwFromDmat(DMAT *dmat) {
    
}
